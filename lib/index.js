const {join} = require('path');
const fs = require('fs').promises;

/**
 * Generate the esm bundled version of a package/subpath + its dependencies
 *
 * @param bundle {string} The package name + subpath
 * @param mode? {string} Can be 'esm' 'sjs', or 'amd'
 * @param specs? {{cwd?: string, cache?: string, temp?: string, dependencies?: boolean}}
 * @return {Promise<{errors: [string]}|any>}
 */
module.exports = async function (bundle, mode, specs) {
    mode = mode ? mode : 'esm';
    specs = specs ? specs : {};
    if (typeof bundle !== 'string' || typeof mode !== 'string' || typeof specs !== 'object') {
        throw new Error('Invalid parameters');
    }

    const exists = file => new Promise(r => fs.access(file)
        .then(() => r(true))
        .catch(() => r(false)));

    if (specs.cwd && !(await exists(specs.cwd))) {
        return {errors: [`Working directory path "${specs.cwd}" does not exist.`]};
    }

    if (specs.cwd && !(await exists(join(specs.cwd, 'node_modules')))) {
        return {errors: [`Working directory "${specs.cwd}" does not have a node_modules folder.`]};
    }

    specs.cwd = specs.cwd ? specs.cwd : process.cwd();
    specs.cache = specs.cache ? specs.cache : join(specs.cwd, '.uimport/cache');
    specs.temp = specs.temp ? specs.temp : join(specs.cwd, '.uimport/temp');

    // Dependencies are generated by default
    specs.dependencies = specs.dependencies === void 0 ? true : !!specs.dependencies;

    const build = async (bundle, cwd) => {
        const {cache, temp} = specs;
        return await require('./bundle')(bundle, mode, {cwd, cache, temp});
    }
    const {code, pkg, subpath, version, errors, warnings, dependencies} = await build(bundle, specs.cwd);
    if (errors) return {errors};

    if (specs.dependencies) {
        // Build the dependencies
        for (const dependency of dependencies) {
            const cwd = (() => {
                const split = dependency.path.split('node_modules');
                split.pop();
                return split.join('node_modules');
            })();

            const {errors} = await build(dependency.id, cwd);
            errors?.length && warnings.push(`Dependency "${dependency.id}" build returned errors`);
        }
    }

    return {errors, warnings, pkg, subpath, code, version, dependencies};
}