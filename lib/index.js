const {join} = require('path');
const fs = require('fs').promises;
const VSpecifierParser = require('./vspecifier-parser');

/**
 * Generate the esm bundled version of a package/subpath + its dependencies
 *
 * @param bundle {string} The package name + subpath
 * @param mode? {string} Can be 'esm' 'sjs', or 'amd'
 * @param specs? {{cwd?: string, cache?: string, temp?: string, dependencies?: boolean}}
 * @return {Promise<{errors: [string]}|any>}
 */
module.exports = async function (bundle, mode, specs) {
    mode = mode ? mode : 'esm';
    specs = specs ? specs : {};
    if (typeof bundle !== 'string' || typeof mode !== 'string' || typeof specs !== 'object') {
        throw new Error('Invalid parameters');
    }

    const exists = file => new Promise(r => fs.access(file)
        .then(() => r(true))
        .catch(() => r(false)));

    if (specs.cwd && !(await exists(specs.cwd))) {
        return {errors: [`Working directory path "${specs.cwd}" does not exist.`]};
    }

    if (specs.cwd && !(await exists(join(specs.cwd, 'node_modules')))) {
        return {errors: [`Working directory "${specs.cwd}" does not have a node_modules folder.`]};
    }

    specs.cwd = specs.cwd ? specs.cwd : process.cwd();
    specs.cache = specs.cache ? specs.cache : join(specs.cwd, '.uimport/cache');
    specs.temp = specs.temp ? specs.temp : join(specs.cwd, '.uimport/temp');

    // Dependencies are generated by default
    specs.dependencies = specs.dependencies === void 0 ? true : !!specs.dependencies;

    const vspecifier = new VSpecifierParser(bundle);
    const pkg = require('uimport/packages').get(vspecifier.pkg, specs);
    await pkg.process();

    if (pkg.error) return {errors: [pkg.error]};

    // Resolve the static resources of a package generated with UImport
    const {subpath} = vspecifier;
    if (pkg.json?.static?.hasOwnProperty(subpath)) {
        const file = join(pkg.path, pkg.json.static[subpath]);
        const code = await fs.readFile(file, 'utf8');
        return {code, dependencies: []};
    }

    /**
     * Process the bundle
     *
     * @param bundle
     * @param cwd
     * @return {Promise<*>}
     */
    const build = async (bundle, cwd) => {
        const {cache, temp, versions, prePath} = specs;
        return await require('./bundle')(pkg, vspecifier, mode, {cwd, cache, temp, versions, prePath});
    }
    const {code, version, errors, warnings, dependencies} = await build(bundle, specs.cwd);
    if (errors) return {errors};

    if (specs.dependencies) {
        // Build the dependencies
        for (const dependency of dependencies) {
            const cwd = (() => {
                const split = dependency.path.split('node_modules');
                split.pop();
                return split.join('node_modules');
            })();

            const {errors} = await build(dependency.id, cwd);
            errors?.length && warnings.push(`Dependency "${dependency.id}" build returned errors`);
        }
    }

    return {errors, warnings, pkg, subpath, code, version, dependencies};
}