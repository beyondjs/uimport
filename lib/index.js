const {join, extname} = require('path');
const fs = require('@beyond-js/fs');
const VSpecifierParser = require('@beyond-js/specifier-parser');

/**
 * Generate the esm bundled version of a package/subpath + its dependencies
 *
 * @param resource {string} The package name + subpath
 * @param mode? {string} Can be 'esm' 'sjs', or 'amd'
 * @param specs? {{cwd?: string, cache?: string, temp?: string, dependencies?: boolean}}
 * @return {Promise<{errors: [string]}|any>}
 */
module.exports = async function (resource, mode, specs) {
    mode = mode ? mode : 'esm';
    specs = specs ? specs : {};

    if (typeof resource !== 'string' || typeof mode !== 'string' || typeof specs !== 'object') {
        throw new Error('Invalid parameters');
    }

    // Remove the extension
    const ext = (() => {
        if (resource.endsWith('.js.map')) return '.js.map';
        if (resource.endsWith('.d.ts')) return '.d.ts';
        return extname(resource);
    })();
    const bundle = resource.slice(0, resource.length - ext.length);

    const exists = file => new Promise(r => fs.access(file)
        .then(() => r(true))
        .catch(() => r(false)));

    if (specs.cwd && !(await exists(specs.cwd))) {
        return {errors: [`Working directory path "${specs.cwd}" does not exist.`]};
    }

    if (specs.cwd && !(await exists(join(specs.cwd, 'node_modules')))) {
        return {errors: [`Working directory "${specs.cwd}" does not have a node_modules folder.`]};
    }

    specs.cwd = specs.cwd ? specs.cwd : process.cwd();
    specs.cache = specs.cache ? specs.cache : join(specs.cwd, '.uimport/cache');
    specs.temp = specs.temp ? specs.temp : join(specs.cwd, '.uimport/temp');

    // Dependencies are generated by default
    specs.dependencies = specs.dependencies === void 0 ? true : !!specs.dependencies;

    const vspecifier = new VSpecifierParser(bundle);
    const pkg = require('uimport/packages').get(vspecifier.pkg, specs);
    await pkg.process();

    if (pkg.error) return {errors: [pkg.error]};

    // Resolve the static resources of a package generated with UImport;
    const {subpath} = vspecifier;
    const entry = `${subpath}${ext}`;
    if (pkg.json?.static?.hasOwnProperty(entry)) {
        const file = join(pkg.path, pkg.json.static[entry]);
        const exists = await fs.exists(file);
        if (!exists) {
            return {errors: [`Static resource "${entry}" not found`]};
        }

        const code = await fs.readFile(file, 'utf8');
        return {code, dependencies: []};
    }
    if (ext !== '.js') {
        if (ext === '.css' && pkg.subpaths.css.has(subpath)) {
            const entry = pkg.subpaths.css.get(subpath);
            const file = join(pkg.path, entry);
            const exists = await fs.exists(file);
            if (!exists) {
                return {errors: [`Entry resource "${entry}" of subpath "${subpath}" not found`]};
            }

            const code = await fs.readFile(file, 'utf8');
            return {code};
        }

        return {errors: [`Resource "${resource}" not found`]};
    }

    /**
     * Process the bundle
     *
     * @param bundle
     * @param cwd
     * @return {Promise<*>}
     */
    const build = async (bundle, cwd) => {
        const {cache, temp, versions, prePath} = specs;
        return await require('./bundle')(pkg, vspecifier, mode, {cwd, cache, temp, versions, prePath});
    }
    const {code, version, errors, warnings, dependencies} = await build(bundle, specs.cwd);
    if (errors) return {errors};

    if (specs.dependencies) {
        // Build the dependencies
        for (const dependency of dependencies) {
            const cwd = (() => {
                const split = dependency.path.split('node_modules');
                split.pop();
                return split.join('node_modules');
            })();

            const {errors} = await build(dependency.id, cwd);
            errors?.length && warnings.push(`Dependency "${dependency.id}" build returned errors`);
        }
    }

    // Valid if the bundle exports styles
    const css = pkg.subpaths.css.has(subpath);

    return {errors, warnings, pkg, subpath, code, version, dependencies, css};
}