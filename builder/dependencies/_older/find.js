/**
 * Returns the resource of a package/subpath from the input generated by the esbuild metafile
 * The returned errors can be:
 *      . errorCode = 1, the package was not found
 *      . errorCode = 2, the package exists, but its subpath was not found
 *
 * @param input {string} The import. Ex: 'node_modules/svelte/internal/internal.js'
 * @param application {{path: string}} The application object
 * @return {{errors: string[]}|{resource, subpath: string, pkg: string, solved: string}}
 */
module.exports = function (input, application) {
    const [, bundle] = input.split('node_modules/');

    const split = bundle.split('/');
    const pkg = split[0].startsWith('@') ? `${split.shift()}/${split.shift()}` : split.shift();
    const resource = split.join('/');

    const resolved = require('./resolve')(pkg, null, application);
    if (resolved.errors || resolved.resource || !resolved.json) {
        return {errors: [`Package "${pkg}" not found`], errorCode: 1};
    }

    // Construct a map with the subpaths and their resources
    const resources = new Map();

    const {json} = resolved;
    if (!json.exports) {
        if (!json.module && !json.main) {
            return {
                errors: [`Resource "${resource}" does not specify the module entry in the package.json`],
                errorCode: 2
            };
        }

        let module = json.module ? json.module : json.main;
        module = module.startsWith('./') ? module.slice(2) : module;
        resources.set(module, '.');
    }

    const exports = (() => {
        if (!json.exports) return;

        const exports = new Map(Object.entries(json.exports));
        exports.forEach((config, subpath) => {
            if (subpath.startsWith('.')) return;

            !exports.has('.') && exports.set('.', {});
            const conditionals = exports.get('.');
            conditionals[subpath] = config;
        });

        return exports
    })();

    exports && exports.forEach((config, subpath) => {
        if (!subpath.startsWith('.') || ['./package.json'].includes(subpath)) return;

        config = (() => {
            config = config.browser ? config.browser : config;
            if (typeof config === 'string') return config;

            config = config.module ? config.module : config;
            if (typeof config === 'string') return config;

            config = config.main ? config.main : config;
            if (typeof config === 'string') return config;

            config = config.import ? config.import : config;
            if (typeof config === 'string') return config;

            return config.browser || config.module || config.main || config.default;
        })();

        if (typeof config !== 'string' || !config.startsWith('./')) return;

        const resource = config.slice(2);
        resources.set(resource, subpath === '.' ? subpath : subpath.slice(2));
    });

    if (!resources.has(resource)) {
        return {errors: [`Resource "${resource}" not found`], errorCode: 2};
    }

    const subpath = resources.get(resource);
    const solved = subpath === '.' ? pkg : `${pkg}/${subpath}`;
    return {pkg, resource, subpath, solved};
}
